# AIE1001 期中复习报告（中文版）

## 引言
这份报告总结了 AIE1001 人工智能编程导论课程第 1 周至第 6 周的关键概念和常见易错点。根据第 8 周期中复习幻灯片，考试（1 小时）包括单选题（40 分）、多选题（15 分）和简答题（45 分，包括代码故障定位、代码补全、函数设计）——不允许作弊单或计算器。

## 第 1 周：人工智能编程导论
### 重点内容
- **数制系统**：
  - **十进制**：基数 10，符号 {0,1,2,3,4,5,6,7,8,9}
  - **二进制**：基数 2，符号 {0,1}，"逢二进一"
  - **八进制**：基数 8，符号 {0,1,2,3,4,5,6,7}，"逢八进一"
  - **十六进制**：基数 16，符号 {0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f}，"逢十六进一"
- **位置记数法**：N = a_n × base^n + a_{n-1} × base^{n-1} + ... + a_0 × base^0 + a_{-1} × base^{-1} + ...
  - a_n 是位置值，base^n 是权重

- **数制转换方法**：

  **1. 其他进制 → 十进制**
  - 方法：按位置记数法展开，每位数字乘以对应权重后求和
  - 示例：二进制转十进制
    ```
    (10110.11)₂ = 1×2⁴ + 0×2³ + 1×2² + 1×2¹ + 0×2⁰ + 1×2⁻¹ + 1×2⁻²
                = 16 + 0 + 4 + 2 + 0 + 0.5 + 0.25
                = (22.75)₁₀
    ```
  - 八进制转十进制：同样方法，基数改为 8
    ```
    (35.7)₈ = 3×8¹ + 5×8⁰ + 7×8⁻¹ = 24 + 5 + 0.875 = (29.875)₁₀
    ```
  - 十六进制转十进制：同样方法，基数改为 16
    ```
    (A7D.E)₁₆ = 10×16² + 7×16¹ + 13×16⁰ + 14×16⁻¹ = 2560 + 112 + 13 + 0.875 = (2685.875)₁₀
    ```

  **2. 十进制 → 二进制**
  - **整数部分**：除以 2，取余数，从低位到高位（最后得到的余数是最高位）
    ```
    示例：(57)₁₀ = (?)₂
    57 ÷ 2 = 28 ... 余 1  ← 最低位
    28 ÷ 2 = 14 ... 余 0
    14 ÷ 2 = 7  ... 余 0
    7  ÷ 2 = 3  ... 余 1
    3  ÷ 2 = 1  ... 余 1
    1  ÷ 2 = 0  ... 余 1  ← 最高位
    答案：(57)₁₀ = (111001)₂
    ```
  - **小数部分**：乘以 2，取整数部分，从高位到低位（第一个整数部分是最高位）
    ```
    示例：(0.875)₁₀ = (?)₂
    0.875 × 2 = 1.75，整数部分 1 ← 最高位
    0.75  × 2 = 1.5， 整数部分 1
    0.5   × 2 = 1.0， 整数部分 1 ← 最低位
    答案：(0.875)₁₀ = (0.111)₂
    ```
  - **整数+小数**：分别转换整数部分和小数部分，然后合并
    ```
    示例：(215.6875)₁₀ = (?)₂
    整数部分：215 = (11010111)₂
    小数部分：0.6875 = (0.1011)₂
    答案：(215.6875)₁₀ = (11010111.1011)₂
    ```

  **3. 二进制 ↔ 八进制**
  - **二进制 → 八进制**：
    - 整数部分：从低位（右）开始，每 3 位二进制一组，转换为 1 位八进制（不足 3 位高位补 0）
    - 小数部分：从高位（左）开始，每 3 位二进制一组，转换为 1 位八进制（不足 3 位低位补 0）
    - 对应关系：3 位二进制 ↔ 1 位八进制
      ```
      (000)₂ = (0)₈    (001)₂ = (1)₈    (010)₂ = (2)₈    (011)₂ = (3)₈
      (100)₂ = (4)₈    (101)₂ = (5)₈    (110)₂ = (6)₈    (111)₂ = (7)₈
      ```
    - 示例：
      ```
      (11010111.1011)₂ = (?)₈
      整数部分：011 010 111 → 3 2 7
      小数部分：101 100（补0）→ 5 4
      答案：(11010111.1011)₂ = (327.54)₈
      ```
  - **八进制 → 二进制**：
    - 将每位八进制数字转换为 3 位二进制，保持顺序不变
    - 示例：
      ```
      (327.54)₈ = (?)₂
      3 → 011,  2 → 010,  7 → 111
      5 → 101,  4 → 100
      答案：(327.54)₈ = (011010111.101100)₂ = (11010111.1011)₂
      ```

  **4. 二进制 ↔ 十六进制**
  - **二进制 → 十六进制**：
    - 整数部分：从低位（右）开始，每 4 位二进制一组，转换为 1 位十六进制（不足 4 位高位补 0）
    - 小数部分：从高位（左）开始，每 4 位二进制一组，转换为 1 位十六进制（不足 4 位低位补 0）
    - 对应关系：4 位二进制 ↔ 1 位十六进制（0-9 对应数字，10-15 对应 a-f）
    - 示例：
      ```
      (11010111.1011)₂ = (?)₁₆
      整数部分：1101 0111 → D 7
      小数部分：1011 0000（补0）→ B 0
      答案：(11010111.1011)₂ = (D7.B)₁₆
      ```
  - **十六进制 → 二进制**：
    - 将每位十六进制数字转换为 4 位二进制，保持顺序不变
    - 示例：
      ```
      (D7.B)₁₆ = (?)₂
      D → 1101,  7 → 0111
      B → 1011
      答案：(D7.B)₁₆ = (11010111.1011)₂
      ```

  **5. 十进制 → 八进制/十六进制**
  - 方法：先转换为二进制，再转换为八进制或十六进制
  - 或者：直接使用对应基数除/乘法（类似十进制转二进制的方法）

- **单位换算**：1 KB = 1024 B (2^10)，1 MB = 1024 KB，1 GB = 1024 MB。
- **计算机基础**：冯·诺伊曼架构、CPU（控制单元和算术逻辑单元）、内存（RAM/ROM）、输入输出设备。
- **变量**：变量是内存中的命名空间，值可以改变。整数变量是不可变的（immutable）。

### 常见易错点
- **小数部分转换方向错误**：十进制转二进制小数，从高位到低位（第一个整数部分是最高位）；整数部分从低位到高位（第一个余数是最低位）。
- **忘记分别处理整数和小数部分**：如果有整数和小数部分，必须分开转换再合并。
- **二进制和八进制/十六进制转换时忘记补零**：
  - 八进制：每 3 位二进制一组，不足 3 位要补 0
  - 十六进制：每 4 位二进制一组，不足 4 位要补 0
  - 整数部分从低位开始分组，小数部分从高位开始分组
- **位置记数法展开时权重错误**：注意整数部分权重从 2⁰（或 8⁰、16⁰）开始，小数部分权重从 2⁻¹（或 8⁻¹、16⁻¹）开始。

## 第 2 周：Python 基础
### 重点内容
- **解释器 vs. 编译器**：解释器直接执行代码，编译器先转换为机器码。Python 使用解释器，支持交互模式（逐行输入）和脚本模式（文件执行）。
- **变量命名规则**：必须以字母或下划线开头；只能包含字母、数字和下划线；大小写敏感；不能使用保留字（如 def, if, while 等）。
- **数据类型**：整数（int）、浮点数（float）、字符串（str）。可用 type() 查看类型。
- **类型转换**：int()、float()、str()。当表达式包含整数和浮点数时，整数会隐式转换为浮点数。
- **运算符**：算术运算符（+, -, *, /, //, %, **）。// 是向下取整除法（floor division），如 -7//2 = -4。** 是幂运算，右结合（如 2**3**2 = 2**(3**2) = 512）。运算符优先级：括号 > 幂 > 乘除余 > 加减。
- **+ 运算符的具体用法**：
  - 字符串：`'hello' + 'world'` = `'helloworld'`（连接）
  - 列表：`[1, 2] + [3, 4]` = `[1, 2, 3, 4]`（连接成新列表）
  - 数字：`3 + 5` = `8`（算术加法）
  - 注意：不能将字符串和数字相加（如 `'2' + 3` 会报错），需要先转换类型
- **赋值**：= 用于赋值；== 用于比较。级联赋值：x = y = z = 0。同时赋值：x, y = y, x（交换两变量）。
- **输入输出**：input() 返回字符串；print() 用于输出。
- **eval() 函数**：
  - `eval()` 函数接受一个字符串参数，将该字符串作为 Python 表达式求值
  - 就像程序员直接输入表达式作为代码一样，函数返回该表达式的结果
  - 示例：`eval('2 + 3')` 返回 `5`；`eval('3 * 4')` 返回 `12`
  - 用途：给程序员灵活性，可以在运行时确定执行什么代码
  - **安全性警告**：应该谨慎使用，因为用户可能输入"不当"输入导致安全问题（如执行删除文件等危险操作）。如果只是处理数字字面量，建议使用 `int()` 或 `float()` 而不是 `eval()`

### 常见易错点
- 忘记 input() 返回字符串，直接用于算术运算导致类型错误（如 '2' + 3）。
- 运算符优先级错误（如 1 + 2 * 3 = 7，不是 9）。
- 脚本模式下缩进错误（必须保持一致的空格或制表符）。
- 混淆 = 和 ==（= 是赋值，== 是比较）。
- 使用 eval() 时注意安全性（会执行任意代码，用户可能输入危险操作；如果只是处理数字，建议用 int() 或 float()）。

## 第 3 周：流程控制
### 重点内容
- **比较运算符**：==, !=, <, >, <=, >=。注意 = 用于赋值，== 用于比较。
- **字符串比较**：字典序比较（lexicographical），基于 ASCII/Unicode 码点。例如 'A' < 'a'（ASCII 中 'A'=65, 'a'=97）。
- **浮点数比较**：浮点数是近似值，0.1 不能精确表示（如 0.1 + 0.2 ≠ 0.3）。Python 的 float 是 IEEE-754 双精度（64 位），只能精确存储约 15-17 位有效数字。
- **布尔类型**：True/False。数字 0 表示 False，所有其他数字表示 True。Falsy 值包括：None, False, 0/0.0/0j, 空序列/集合（"", [], {}, set(), range(0)）。其他都是 truthy。
- **条件语句**：if（单路）、if-else（双路）、if-elif-else（多路）。注意缩进和 elif 的位置。
- **循环**：while（不定循环，条件为 False 时停止）、for（定循环，遍历序列）。range() 函数生成数字序列。break 退出循环，continue 跳过本次迭代。
- **异常处理**：try/except 捕获错误（如 ValueError）。

### 常见易错点
- 浮点数精度问题（如 0.1 + 0.2 == 0.30000000000000004）。
- 字符串比较时忽略大小写和 Unicode 字符。
- 循环条件中的越界错误（如 while i < len(s) vs. i <= len(s)）。
- 缩进不一致导致语法错误。
- 忘记 else 或 elif 位置错误。
- 无限循环（缺少终止条件或忘记更新循环变量）。

## 第 4 周：函数
### 重点内容
- **函数定义**：def 函数名(参数): 函数体。函数签名表示函数名和参数数量。
- **参数和参数**：参数（parameter）是函数定义中的变量；参数（argument）是调用时传入的值。
- **返回值**：return 语句返回结果，函数执行结束。没有 return 时返回 None（无返回值函数/void function）。
- **作用域**：局部变量（函数内定义）和全局变量（函数外定义）。函数内可以使用 global 关键字声明全局变量（需谨慎使用）。
- **默认参数**：函数定义时可以给参数设置默认值，调用时可以不传该参数。
- **返回多个值**：可以返回多个值（实际上是元组），调用时用同时赋值接收（如 x, y = func()）。

### 常见易错点
- 调用时参数顺序或数量不匹配。
- 作用域错误：修改局部变量不影响全局变量；意外使用全局变量。
- 忘记 return 语句，导致返回 None。
- 默认参数在函数定义时求值（如果默认值是可变对象如列表，会共享同一个对象）。
- 过度使用全局变量，导致代码难以调试。

## 第 5 周：列表、字典和元组
### 重点内容
- **列表**：可变序列，用方括号 []。可以通过索引访问元素（从 0 开始）。len() 返回长度。append() 添加元素。sort() 原地排序。可以用 + 连接，* 重复。切片操作类似字符串（第二个数字是"包含但不包括"）。
  - 列表 + 运算符：`[1, 2] + [3, 4]` = `[1, 2, 3, 4]`（创建新列表，不修改原列表）
  - 列表 * 运算符：`[1, 2] * 3` = `[1, 2, 1, 2, 1, 2]`（重复）
- **range() 函数**：返回数字序列，用于 for 循环。例如 range(5) 产生 [0,1,2,3,4]。注意：range() 在 Python 3 返回的是 range 对象，不是列表。
- **字典**：用花括号 {}，键值对格式 {key: value}。无序集合（但 Python 3.7+ 保持插入顺序）。通过键访问值，如果键不存在会报 KeyError。
- **get() 方法具体用法**：
  - 语法：`字典.get(键, 默认值)`
  - 如果键存在，返回对应的值；如果键不存在，返回默认值（不报错）
  - 示例：`d = {'a': 1, 'b': 2}`，则 `d.get('a', 0)` 返回 `1`，`d.get('c', 0)` 返回 `0`
  - 如果不提供默认值，键不存在时返回 None：`d.get('c')` 返回 `None`
- **字典计数模式**：
  ```python
  d = {}
  word = 'hello'
  d[word] = d.get(word, 0) + 1  # 如果 word 不在字典中，先返回 0，然后加 1
  ```
- **字典遍历的三种方式**：
  1. **直接遍历字典**：`for key in d:` 或 `for key in d.keys():` - 遍历的是**键**（keys），不是值。如果需要值，要用 `d[key]` 查找。
  2. **遍历值**：`for value in d.values():` - 只遍历值，无法直接获取对应的键
  3. **遍历键值对（推荐）**：`for key, value in d.items():` - 用两个迭代变量同时获取键和值
  - 示例：
    ```python
    d = {'a': 1, 'b': 2}
    # 方式1：遍历键
    for k in d:
        print(k, d[k])  # 输出：a 1, b 2
    # 方式2：遍历键值对
    for k, v in d.items():
        print(k, v)  # 输出：a 1, b 2
    ```
  - 注意：直接遍历字典（`for key in d`）实际上遍历的是键，不是值，也不是键值对
- **元组**：不可变序列，用圆括号 ()。
  - **元组初始化**：
    - 空元组：`t = ()` 或 `t = tuple()`
    - 单元素元组：`t = (1,)` **注意**：必须有逗号，`(1)` 是整数，不是元组
    - 多元素元组：`t = (1, 2, 3)` 或 `t = 1, 2, 3`（不带括号也可以，但建议带上）
  - **元组基本操作**：
    - 索引访问：`t[0]` 访问第一个元素（索引从 0 开始）
    - 切片：`t[1:3]` 获取子元组（注意：切片返回新元组）
    - 长度：`len(t)` 返回元素个数
    - 遍历：`for item in t:` 遍历元组中的每个元素
    - 连接：`t1 + t2` 连接两个元组，返回新元组
    - 重复：`t * 3` 重复元组，返回新元组
    - 检查成员：`1 in t` 检查元素是否在元组中
  - **元组特性**：
    - 不可变（immutable）：创建后不能修改，不能添加、删除或修改元素
    - 可以作为字典的键（因为不可变）
    - 可以用 `items()` 方法获取字典的键值对元组列表：`d.items()` 返回 `[('a', 1), ('b', 2)]`
    - 比列表更高效（内存和性能方面），适合作为临时变量
- **元组比较**：元组可以比较，按字典序（从第一个元素开始，如果相同则比较下一个）。
  - 比较规则：逐个比较对应位置的元素，直到找到不同的元素
  - 示例：
    ```python
    (1, 2, 3) < (2, 1, 1)  # True，因为 1 < 2
    (1, 2, 3) < (1, 3, 1)  # True，因为 2 < 3
    (1, 2) < (1, 2, 3)     # True，较短的元组更小
    (1, 2, 3) == (1, 2, 3) # True，完全相等
    ```
  - 注意：对应位置的元素类型必须可以比较（如不能比较字符串和数字）
- **排序**：list.sort() 原地排序；sorted() 返回新列表。可以对字典的 items() 进行排序（因为 items() 返回的是元组列表）。

### 常见易错点
- 索引越界（列表/字符串/元组从 0 开始，len() 不包括最后一个索引）。
- **元组初始化错误**：
  - 创建单元素元组时忘记逗号：`(1)` 是整数，不是元组；应该用 `(1,)`
  - 空元组用 `()`，但不要和函数的括号混淆
- **尝试修改元组**（TypeError: 'tuple' object does not support item assignment）：
  - 元组创建后不能修改：不能 `t[0] = 1`，不能 `t.append(1)`，不能 `t.remove(1)`
  - 如果需要修改，应该创建新元组或使用列表
- 字典键不存在时访问导致 KeyError：使用 `d['key']` 访问不存在的键会报错，应该用 `d.get('key', 默认值)` 或先检查 `'key' in d`。
- 直接遍历字典时误以为遍历的是值：`for item in d:` 遍历的是键，需要 `d[item]` 才能获取值，或直接用 `for k, v in d.items()`。
- 混淆 sort() 和 sorted()（前者改变原列表，后者返回新列表）。
- 列表连接时使用 + 而不是 append()，导致效率问题：
  - `lst = lst + [x]` 创建新列表，效率低（O(n)）
  - `lst.append(x)` 修改原列表，效率高（O(1) 摊销）
  - 在循环中频繁使用 `+` 会很慢，应该用 `append()`

## 第 6 周：递归
### 重点内容
- **递归概念**：函数调用自身。递归定义包含：基例（base case，简单情况，无需递归）和递归例（recursive case，将问题缩小为更小版本）。
- **阶乘示例**：n! = n × (n-1)!，基例是 0! = 1。
- **递归实现**：Python 每次函数调用时创建激活记录（activation record/frame），存储参数和局部变量。函数调用时暂停当前函数，记录返回位置，最后调用的先返回（last called, first to finish）。
- **环境图**：可以绘制环境图追踪递归过程，每个调用有自己的帧，n 的值取决于当前环境。
- **递归树**：另一种可视化递归的方式，显示函数调用树。
- **二分搜索**：对有序列表的递归搜索算法。维护 low 和 high 两个参数，比较中间元素 data[mid]，如果目标小则递归左半部分，大则递归右半部分。
- **线性递归**：每次调用最多只进行一次递归调用（如阶乘、二分搜索）。
- **多重递归**：每次调用进行两次或更多递归调用（如斐波那契、英式尺子绘制）。

### 常见易错点
- 缺少或不正确的基例，导致无限递归（如 fact(0) 未处理）。
- 递归条件错误（如 n-1 时 n==1 的情况）。
- 递归深度过深导致栈溢出（Python 默认递归限制约 1000）。
- 不理解调用栈：每个调用有自己的帧，返回时依次展开。
- 多重递归效率低（如斐波那契会重复计算，应该用记忆化或动态规划）。
- 忘记在递归例中缩小问题规模（如 fact(n) = n * fact(n) 会无限循环）。

## 结论
专注于练习代码执行（可使用 Python Tutor 可视化递归和循环）。常见错误往往源于类型、作用域和越界索引。复习数制转换和浮点数精度问题。根据第 8 周期中复习，预期问题包括：数制转换（如二进制小数）、循环（如 range 列表推导）、字典（如 get() 用于计数）、递归追踪（环境图）和代码调试（如元组不可变错误、KeyError）。简答题需要练习故障定位（如缺少基例）和代码补全（如递归求和）。考试中，强调编写正确的 Python 代码，包括函数、循环和递归解决方案。祝好运！

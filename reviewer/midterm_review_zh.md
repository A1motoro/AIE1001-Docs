# AIE1001 期中复习报告（中文版）

## 引言
这份报告总结了 AIE1001 人工智能编程导论课程第 1 周至第 6 周的关键概念和常见易错点。根据第 8 周期中复习幻灯片，考试（1 小时）包括单选题（40 分）、多选题（15 分）和简答题（45 分，包括代码故障定位、代码补全、函数设计）——不允许作弊单或计算器。

## 第 1 周：人工智能编程导论
### 重点内容
- **数制转换**：十进制、二进制、八进制、十六进制的相互转换。位置记数法：N = a_n × base^n + a_{n-1} × base^{n-1} + ... + a_0 × base^0 + a_{-1} × base^{-1} + ...。注意：二进制小数转换时，将小数部分乘以 2，取整数部分作为下一位，从高位到低位。
- **单位换算**：1 KB = 1024 B (2^10)，1 MB = 1024 KB，1 GB = 1024 MB。
- **计算机基础**：冯·诺伊曼架构、CPU（控制单元和算术逻辑单元）、内存（RAM/ROM）、输入输出设备。
- **变量**：变量是内存中的命名空间，值可以改变。整数变量是不可变的（immutable）。

### 常见易错点
- 小数部分转换时忘记方向：十进制转二进制小数，从高位到低位；整数部分从低位到高位。
- 转换时忘记分别处理整数和小数部分：如果有整数和小数部分，需要分开转换再合并。
- 二进制和八进制/十六进制转换时忘记补零：八进制每 3 位二进制，十六进制每 4 位二进制。

## 第 2 周：Python 基础
### 重点内容
- **解释器 vs. 编译器**：解释器直接执行代码，编译器先转换为机器码。Python 使用解释器，支持交互模式（逐行输入）和脚本模式（文件执行）。
- **变量命名规则**：必须以字母或下划线开头；只能包含字母、数字和下划线；大小写敏感；不能使用保留字（如 def, if, while 等）。
- **数据类型**：整数（int）、浮点数（float）、字符串（str）。可用 type() 查看类型。
- **类型转换**：int()、float()、str()。当表达式包含整数和浮点数时，整数会隐式转换为浮点数。
- **运算符**：算术运算符（+, -, *, /, //, %, **）。// 是向下取整除法（floor division），如 -7//2 = -4。** 是幂运算，右结合。运算符优先级：括号 > 幂 > 乘除余 > 加减。
- **赋值**：= 用于赋值；== 用于比较。级联赋值：x = y = z = 0。同时赋值：x, y = y, x（交换两变量）。
- **输入输出**：input() 返回字符串；print() 用于输出；eval() 可以将字符串作为 Python 表达式执行。

### 常见易错点
- 忘记 input() 返回字符串，直接用于算术运算导致类型错误（如 '2' + 3）。
- 运算符优先级错误（如 1 + 2 * 3 = 7，不是 9）。
- 脚本模式下缩进错误（必须保持一致的空格或制表符）。
- 混淆 = 和 ==（= 是赋值，== 是比较）。
- 使用 eval() 时注意安全性（会执行任意代码）。

## 第 3 周：流程控制
### 重点内容
- **比较运算符**：==, !=, <, >, <=, >=。注意 = 用于赋值，== 用于比较。
- **字符串比较**：字典序比较（lexicographical），基于 ASCII/Unicode 码点。例如 'A' < 'a'（ASCII 中 'A'=65, 'a'=97）。
- **浮点数比较**：浮点数是近似值，0.1 不能精确表示（如 0.1 + 0.2 ≠ 0.3）。Python 的 float 是 IEEE-754 双精度（64 位），只能精确存储约 15-17 位有效数字。
- **布尔类型**：True/False。数字 0 表示 False，所有其他数字表示 True。Falsy 值包括：None, False, 0/0.0/0j, 空序列/集合（"", [], {}, set(), range(0)）。其他都是 truthy。
- **条件语句**：if（单路）、if-else（双路）、if-elif-else（多路）。注意缩进和 elif 的位置。
- **循环**：while（不定循环，条件为 False 时停止）、for（定循环，遍历序列）。range() 函数生成数字序列。break 退出循环，continue 跳过本次迭代。
- **异常处理**：try/except 捕获错误（如 ValueError）。

### 常见易错点
- 浮点数精度问题（如 0.1 + 0.2 == 0.30000000000000004）。
- 字符串比较时忽略大小写和 Unicode 字符。
- 循环条件中的越界错误（如 while i < len(s) vs. i <= len(s)）。
- 缩进不一致导致语法错误。
- 忘记 else 或 elif 位置错误。
- 无限循环（缺少终止条件或忘记更新循环变量）。

## 第 4 周：函数
### 重点内容
- **函数定义**：def 函数名(参数): 函数体。函数签名表示函数名和参数数量。
- **参数和参数**：参数（parameter）是函数定义中的变量；参数（argument）是调用时传入的值。
- **返回值**：return 语句返回结果，函数执行结束。没有 return 时返回 None（无返回值函数/void function）。
- **作用域**：局部变量（函数内定义）和全局变量（函数外定义）。函数内可以使用 global 关键字声明全局变量（需谨慎使用）。
- **默认参数**：函数定义时可以给参数设置默认值，调用时可以不传该参数。
- **返回多个值**：可以返回多个值（实际上是元组），调用时用同时赋值接收（如 x, y = func()）。

### 常见易错点
- 调用时参数顺序或数量不匹配。
- 作用域错误：修改局部变量不影响全局变量；意外使用全局变量。
- 忘记 return 语句，导致返回 None。
- 默认参数在函数定义时求值（如果默认值是可变对象如列表，会共享同一个对象）。
- 过度使用全局变量，导致代码难以调试。

## 第 5 周：列表、字典和元组
### 重点内容
- **列表**：可变序列，用方括号 []。可以通过索引访问元素（从 0 开始）。len() 返回长度。append() 添加元素。sort() 原地排序。可以用 + 连接，* 重复。切片操作类似字符串（第二个数字是"包含但不包括"）。
- **range() 函数**：返回数字序列，用于 for 循环。例如 range(5) 产生 [0,1,2,3,4]。注意：range() 在 Python 3 返回的是 range 对象，不是列表。
- **字典**：用花括号 {}，键值对格式 {key: value}。无序集合（但 Python 3.7+ 保持插入顺序）。通过键访问值，如果键不存在会报 KeyError。可以用 get() 方法获取值，不存在时返回默认值。
- **字典计数**：常见用法是用字典统计频率，如 d[word] = d.get(word, 0) + 1。
- **字典遍历**：可以用 for 循环遍历键；keys()、values()、items() 方法获取键/值/键值对。可以用两个迭代变量遍历键值对：for k, v in d.items()。
- **元组**：不可变序列，用圆括号 ()。元组可以作为字典的键（因为不可变）。可以用 items() 方法获取字典的键值对元组列表。
- **元组比较**：元组可以比较，按字典序（从第一个元素开始，如果相同则比较下一个）。
- **排序**：list.sort() 原地排序；sorted() 返回新列表。可以对字典的 items() 进行排序。

### 常见易错点
- 索引越界（列表/字符串从 0 开始，len() 不包括最后一个索引）。
- 尝试修改元组（TypeError: 'tuple' object does not support item assignment）。
- 字典键不存在时访问导致 KeyError（应该用 get() 或先检查 in）。
- 混淆 sort() 和 sorted()（前者改变原列表，后者返回新列表）。
- 列表连接时使用 + 而不是 append()，导致效率问题（如 lst = lst + [x] 是 O(n)，而 append() 是 O(1)）。

## 第 6 周：递归
### 重点内容
- **递归概念**：函数调用自身。递归定义包含：基例（base case，简单情况，无需递归）和递归例（recursive case，将问题缩小为更小版本）。
- **阶乘示例**：n! = n × (n-1)!，基例是 0! = 1。
- **递归实现**：Python 每次函数调用时创建激活记录（activation record/frame），存储参数和局部变量。函数调用时暂停当前函数，记录返回位置，最后调用的先返回（last called, first to finish）。
- **环境图**：可以绘制环境图追踪递归过程，每个调用有自己的帧，n 的值取决于当前环境。
- **递归树**：另一种可视化递归的方式，显示函数调用树。
- **二分搜索**：对有序列表的递归搜索算法。维护 low 和 high 两个参数，比较中间元素 data[mid]，如果目标小则递归左半部分，大则递归右半部分。
- **线性递归**：每次调用最多只进行一次递归调用（如阶乘、二分搜索）。
- **多重递归**：每次调用进行两次或更多递归调用（如斐波那契、英式尺子绘制）。

### 常见易错点
- 缺少或不正确的基例，导致无限递归（如 fact(0) 未处理）。
- 递归条件错误（如 n-1 时 n==1 的情况）。
- 递归深度过深导致栈溢出（Python 默认递归限制约 1000）。
- 不理解调用栈：每个调用有自己的帧，返回时依次展开。
- 多重递归效率低（如斐波那契会重复计算，应该用记忆化或动态规划）。
- 忘记在递归例中缩小问题规模（如 fact(n) = n * fact(n) 会无限循环）。

## 结论
专注于练习代码执行（可使用 Python Tutor 可视化递归和循环）。常见错误往往源于类型、作用域和越界索引。复习数制转换和浮点数精度问题。根据第 8 周期中复习，预期问题包括：数制转换（如二进制小数）、循环（如 range 列表推导）、字典（如 get() 用于计数）、递归追踪（环境图）和代码调试（如元组不可变错误、KeyError）。简答题需要练习故障定位（如缺少基例）和代码补全（如递归求和）。考试中，强调编写正确的 Python 代码，包括函数、循环和递归解决方案。祝好运！
